#include "pbr_pipeline_layout.h"
#include "utils.h"
#include "pbr_utils.h"

#define EG_PIXEL_COORDS vec2(gl_GlobalInvocationID)
#include "shadows_utils.h"

#extension GL_EXT_nonuniform_qualifier : enable

layout(set = 2, binding = 0, rgba32f) uniform writeonly image2D g_Result;

layout(push_constant) uniform PushConstants
{
    mat4 g_ViewProjInv;
    vec3 g_CameraPos;
    float g_MaxReflectionLOD;
    ivec2 g_Size;
    float g_MaxShadowDistance2; // Square of distance
    float g_CSMOverlap;
#ifdef EG_STUTTERLESS
    uint g_PointLightsCount;
    uint g_SpotLightsCount;
    uint g_HasDirLight;
#endif
};

#ifndef EG_STUTTERLESS
layout(constant_id = 0) const uint g_PointLightsCount = 0u;
layout(constant_id = 1) const uint g_SpotLightsCount = 0u;
layout(constant_id = 2) const uint g_HasDirLight = 0u;
#endif
layout(constant_id = 3) const bool s_HasIrradiance = false;

vec3 GTAOMultiBounce(vec3 albedo, float ao)
{
    const vec3 a =  2.0404f * albedo - 0.3324f;
    const vec3 b = -4.7951f * albedo + 0.6417f;
    const vec3 c =  2.7552f * albedo + 0.6903f;

    return max(vec3(ao), ((a * ao + b) * ao + c) * ao);
}

#define GROUP_SIZE 8
layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;

void main()
{
    const ivec2 pixelCoords = ivec2(gl_GlobalInvocationID);
    if (pixelCoords.x >= g_Size.x || pixelCoords.y >= g_Size.y)
        return;

    const vec2 texelSize = 1.f / g_Size;
    const vec2 uv = (pixelCoords + 0.5) * texelSize;

    const vec4 albedo_roughness = texture(g_AlbedoTexture, uv);
    const vec3 lambert_albedo = albedo_roughness.rgb * EG_INV_PI;
    const float depth = texture(g_DepthTexture, uv).x;
    const vec3 worldPos = WorldPosFromDepth(g_ViewProjInv, uv, depth);
    const vec2 materialData = texture(g_MaterialDataTexture, uv).xy;

    const float metallness = materialData.x;
    const float ao = materialData.y;
    const float roughness = albedo_roughness.a;
    const vec3 F0 = mix(vec3(EG_BASE_REFLECTIVITY), albedo_roughness.rgb, metallness);

    const vec3 fragToCamera = g_CameraPos - worldPos;
    const bool bInShadowRange = dot(fragToCamera, fragToCamera) < g_MaxShadowDistance2;
    const vec3 V = normalize(fragToCamera);

    vec3 Lo = vec3(0.f);
    const vec4 encodedNormals = texture(g_GeometryShadingNormalsTexture, uv); // xy - geometry, zw - shading

    // PointLights
    uint plShadowMapIndex = 0;
    for (uint i = 0; i < g_PointLightsCount; ++i)
    {
        const PointLight pointLight = g_PointLights[i];
        const vec3 incoming = pointLight.Position - worldPos;
	    const float distance2 = dot(incoming, incoming);
        const bool bCastsShadows = (floatBitsToUint(pointLight.Radius2) & 0x80000000) != 0;
        if (distance2 > abs(pointLight.Radius2))
        {
            if (bCastsShadows)
                plShadowMapIndex++;
            continue;
        }
	    const float attenuation = 1.f / distance2;

        const vec3 normIncoming = normalize(incoming);
        float shadow = 1.f;
#ifdef EG_TRANSLUCENT_SHADOWS
        vec3 coloredShadow = vec3(1.f);
#endif
        if (bCastsShadows)
        {
            if (bInShadowRange && NOT_ZERO(attenuation))
            {
                if (plShadowMapIndex < EG_MAX_LIGHT_SHADOW_MAPS)
                {
                    const vec3 geometryNormal = DecodeNormal(encodedNormals.xy);
                    const float NdotL = clamp(dot(normIncoming, geometryNormal), EG_FLT_SMALL, 1.0);
                    shadow = PointLight_ShadowCalculation(g_PointShadowMaps[nonuniformEXT(plShadowMapIndex)], -incoming, normIncoming, NdotL);
#ifdef EG_TRANSLUCENT_SHADOWS
                    coloredShadow = PointLight_ColoredShadowCalculation(g_PointShadowMapsColored[nonuniformEXT(plShadowMapIndex)], -incoming, geometryNormal, NdotL);
#endif
                }
            }

            plShadowMapIndex++;
        }

        const vec3 shadingNormal = DecodeNormal(encodedNormals.zw);
        const vec3 pointLightLo = EvaluatePBR(lambert_albedo, normIncoming, V, shadingNormal, F0, metallness, roughness, pointLight.LightColor, attenuation);
#ifdef EG_TRANSLUCENT_SHADOWS
        Lo += pointLightLo * coloredShadow * shadow;
#else
        Lo += pointLightLo * shadow;
#endif
    }

    // SpotLights
    uint slShadowMapIndex = 0;
    for (uint i = 0; i < g_SpotLightsCount; ++i)
    {
        const SpotLight spotLight = g_SpotLights[i];
        const vec3 incoming = spotLight.Position - worldPos;
	    const float distance2 = dot(incoming, incoming);
        if (distance2 > spotLight.Distance2)
        {
            if (spotLight.bCastsShadows != 0)
                slShadowMapIndex++;
            continue;
        }

	    float attenuation = 1.f / distance2;

        const vec3 normIncoming = normalize(incoming);

        //Cutoff
	    const float innerCutOffCos = cos(spotLight.InnerCutOffRadians);
	    const float outerCutOffCos = cos(spotLight.OuterCutOffRadians);
	    const float epsilon = innerCutOffCos - outerCutOffCos;
        const float theta = clamp(dot(normIncoming, normalize(-spotLight.Direction)), EG_FLT_SMALL, 1.0);
	    const float cutoffIntensity = clamp((theta - outerCutOffCos) / epsilon, 0.0, 1.0);
        attenuation *= cutoffIntensity;

#ifdef EG_TRANSLUCENT_SHADOWS
        vec3 coloredShadow = vec3(1.f);
#endif
        float shadow = 1.f;
        if (spotLight.bCastsShadows != 0)
        {
            if (bInShadowRange && NOT_ZERO(attenuation))
            {
                if (slShadowMapIndex < EG_MAX_LIGHT_SHADOW_MAPS)
                {
                    const vec3 geometryNormal = DecodeNormal(encodedNormals.xy);
                    const float NdotL = clamp(dot(normIncoming, geometryNormal), EG_FLT_SMALL, 1.0);
                    const float texelSize = 1.f / textureSize(g_SpotShadowMaps[nonuniformEXT(slShadowMapIndex)], 0).x;
	                const float k = 20.f + (40.f * spotLight.OuterCutOffRadians * spotLight.OuterCutOffRadians) + distance2 * 2.2f; // Some magic number that help to fight against self-shadowing
	                const float bias = texelSize * k;
	                const vec3 normalBias = normIncoming * bias;
                    vec4 lightSpacePos = spotLight.ViewProj * vec4(worldPos + normalBias, 1.0);
                    lightSpacePos.xyz /= lightSpacePos.w;

#ifdef EG_TRANSLUCENT_SHADOWS
                    coloredShadow = SpotLight_ColoredShadowCalculation(g_SpotShadowMapsColored[nonuniformEXT(slShadowMapIndex)], lightSpacePos.xyz, NdotL);
#endif
                    shadow = SpotLight_ShadowCalculation(g_SpotShadowMaps[nonuniformEXT(slShadowMapIndex)], lightSpacePos.xyz, NdotL);
                }
            }

            slShadowMapIndex++;
        }
        const vec3 shadingNormal = DecodeNormal(encodedNormals.zw);
        const vec3 spotLightLo = EvaluatePBR(lambert_albedo, normIncoming, V, shadingNormal, F0, metallness, roughness, spotLight.LightColor, attenuation);
#ifdef EG_TRANSLUCENT_SHADOWS
        Lo += spotLightLo * coloredShadow * shadow;
#else
        Lo += spotLightLo * shadow;
#endif
    }

    // Directional light
#ifdef EG_ENABLE_CSM_VISUALIZATION
    vec3 cascadeVisualizationColor = vec3(0.f);
#endif

    if (g_HasDirLight != 0)
    {
        const float cascadeDepth = abs((g_CameraView * vec4(worldPos, 1.0)).z);
        int layer = GetCascadeIndex(g_DirectionalLight, cascadeDepth);

        const vec3 incoming = normalize(-g_DirectionalLight.Direction);
        float shadow = 1.f;
#ifdef EG_TRANSLUCENT_SHADOWS
        vec3 coloredShadow = vec3(1.f);
#endif
        if (layer != -1)
        {
#ifdef EG_ENABLE_CSM_VISUALIZATION
            const vec3 cascadeColors[EG_CASCADES_COUNT] = vec3[]
            (
                vec3(1, 0, 0),
                vec3(0, 1, 0),
                vec3(0, 0, 1),
                vec3(1, 0, 1)
            );
            cascadeVisualizationColor = cascadeColors[layer];
#endif // EG_ENABLE_CSM_VISUALIZATION
            if (g_DirectionalLight.bCastsShadows != 0 && bInShadowRange)
            {
                const vec3 geometryNormal = DecodeNormal(encodedNormals.xy);
                const float NdotL = clamp(dot(incoming, geometryNormal), EG_FLT_SMALL, 1.0);

            	const float texelSize = 1.f / textureSize(g_DirShadowMaps[nonuniformEXT(layer)], 0).x;
                const float k = GetCascadeTexelOffset(layer);
                const float bias = texelSize * k;
                const vec3 normalBias = geometryNormal * bias;

                const vec3 lightSpacePosBiased = (g_DirectionalLight.ViewProj[layer] * vec4(worldPos + normalBias + incoming * bias * 1.5f, 1.0)).xyz;
                const vec3 lightSpacePos = (g_DirectionalLight.ViewProj[layer] * vec4(worldPos, 1.0)).xyz;
                shadow = DirLight_ShadowCalculation(g_DirShadowMaps[nonuniformEXT(layer)], lightSpacePosBiased, NdotL, layer);
#ifdef EG_TRANSLUCENT_SHADOWS
                coloredShadow = DirLight_ColoredShadowCalculation(g_DirShadowMapsColored[nonuniformEXT(layer)], lightSpacePos, NdotL, layer);
#endif

#ifdef EG_CSM_SMOOTH_TRANSITION
                if (layer != EG_CASCADES_COUNT - 1)
                {
                    const float currentSplit = g_DirectionalLight.CascadePlaneDistances[layer];
                    const float nextSplit = currentSplit - currentSplit * g_CSMOverlap;
                    const float blendFactor = (cascadeDepth - nextSplit) / (currentSplit - nextSplit);
                    if (blendFactor > 0.f)
                    {
                        layer = layer + 1;
                        const float texelSize = 1.f / textureSize(g_DirShadowMaps[nonuniformEXT(layer)], 0).x;
                        const float bias = texelSize * k;
                        const vec3 normalBias = geometryNormal * bias;
                        const vec3 lightSpacePosBiased = (g_DirectionalLight.ViewProj[layer] * vec4(worldPos + normalBias + incoming * bias * 1.5f, 1.0)).xyz;
                        const vec3 lightSpacePos = (g_DirectionalLight.ViewProj[layer] * vec4(worldPos, 1.0)).xyz;
                        const float nextShadow = DirLight_ShadowCalculation(g_DirShadowMaps[nonuniformEXT(layer)], lightSpacePosBiased, NdotL, layer);
                        shadow = mix(shadow, nextShadow, blendFactor);

#ifdef EG_TRANSLUCENT_SHADOWS
                        const vec3 nextColoredShadow = DirLight_ColoredShadowCalculation(g_DirShadowMapsColored[nonuniformEXT(layer)], lightSpacePos, NdotL, layer);
                        coloredShadow = mix(coloredShadow, nextColoredShadow, blendFactor);
#endif
                    }
                }
#endif // EG_CSM_SMOOTH_TRANSITION
            }
        }
        const vec3 shadingNormal = DecodeNormal(encodedNormals.zw);
        const vec3 directional_Lo = EvaluatePBR(lambert_albedo, incoming, V, shadingNormal, F0, metallness, roughness, g_DirectionalLight.LightColor, 1.f);
#ifdef EG_TRANSLUCENT_SHADOWS
        Lo += directional_Lo * shadow * coloredShadow;
#else
        Lo += directional_Lo * shadow;
#endif
    }

    // Ambient
    vec3 ambient = (g_HasDirLight != 0) ? (albedo_roughness.rgb * g_DirectionalLight.Ambient) : vec3(0.f);
    if (s_HasIrradiance)
    {
        const vec3 shadingNormal = DecodeNormal(encodedNormals.zw);
        const vec3 R = reflect(-V, shadingNormal);
        const float NdotV = clamp(dot(shadingNormal, V), EG_FLT_SMALL, 1.0);

        const vec3 Fr = max(vec3(1.f - roughness), F0) - F0;
        const vec3 kS = F0 + Fr * pow(1.f - NdotV, 5.f);

        const vec2 envBRDF = texture(g_BRDFLUT, vec2(NdotV, roughness)).rg;
        const vec3 FssEss = kS * envBRDF.x + envBRDF.y;

        // Multiple scattering, from Fdez-Aguera
        const float Ems = (1.0 - (envBRDF.x + envBRDF.y));
        const vec3 Favg = F0 + (1.0 - F0) / 21.0;
        const vec3 FmsEms = Ems * FssEss * Favg / (1.0 - Favg * Ems);

        const vec3 diffuseColor = albedo_roughness.rgb * (1.f - EG_BASE_REFLECTIVITY) * (1.f - metallness);
        const vec3 kD = diffuseColor * (1.0 - FssEss - FmsEms);

        const vec3 radiance = textureLod(g_PrefilterMap, R, roughness * g_MaxReflectionLOD).rgb;
        const vec3 irradiance = texture(g_IrradianceMap, shadingNormal).rgb;
        const vec3 color = FssEss * radiance + (FmsEms + kD) * irradiance;
        ambient += color * ao;
    }
#ifdef EG_SSAO
        ambient *= GTAOMultiBounce(albedo_roughness.rgb, texture(g_SSAO, uv).x);
#endif

    vec3 resultColor = ambient + Lo + texture(g_EmissiveTexture, uv).xyz;
#ifdef EG_ENABLE_CSM_VISUALIZATION
    resultColor += cascadeVisualizationColor;
#endif

    imageStore(g_Result, pixelCoords, vec4(resultColor, 1.f));
}

#include "utils.h"

layout(push_constant) uniform PushConstants
{
    mat4 g_ProjMat;
    vec3 g_ViewRow1;
    uint unused;
    vec3 g_ViewRow2;
    float g_Radius;
    vec3 g_ViewRow3;
    float g_Bias;

    vec2 g_NoiseScale;
    ivec2 g_Size;
};

layout(binding = 0) uniform sampler2D g_Normal;
layout(binding = 1) uniform sampler2D g_Depth;
layout(binding = 2) uniform sampler2D g_Noise;
layout(binding = 3) buffer SamplesBuffer
{
    vec3 g_Samples[];
};
layout(binding = 4, r8) uniform writeonly image2D g_Result;

#define GROUP_SIZE 8
layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;

void main()
{
    const ivec2 pixelCoords = ivec2(gl_GlobalInvocationID);
    if (pixelCoords.x >= g_Size.x || pixelCoords.y >= g_Size.y)
        return;

    const vec2 texelSize = 1.f / g_Size;
    const vec2 uv = (pixelCoords + 0.5f) * texelSize;

    const mat4 invProj = inverse(g_ProjMat);
    const mat3 viewMat = mat3(g_ViewRow1, g_ViewRow2, g_ViewRow3);

    const float depth = texture(g_Depth, uv).x;
    if (depth == 1.f)
    {
        imageStore(g_Result, pixelCoords, vec4(0.f));
        return;
    }

    const vec3 viewPos = ViewPosFromDepth(invProj, uv, depth);
    const vec3 viewNormal = viewMat * DecodeNormal(texture(g_Normal, uv).zw); // zw - is a shading normal
    const vec3 randomVec = vec3(texture(g_Noise, uv * g_NoiseScale).xy, 0.f);
    
    const vec3 tangent = normalize(randomVec - viewNormal * dot(randomVec, viewNormal));
    const vec3 bitangent = cross(viewNormal, tangent);
    const mat3 TBN = mat3(tangent, bitangent, viewNormal);
    
    // TODO: Improve by using only depth?
    float occlusion = 0.f;
    for (uint i = 0; i < EG_SSAO_SAMPLES; ++i)
    {
        vec3 samplePos = TBN * g_Samples[i]; // From tangent to View-space
        samplePos = viewPos + samplePos * g_Radius;
        vec4 clipSpacePos = g_ProjMat * vec4(samplePos, 1.0);
        clipSpacePos /= clipSpacePos.w;
        clipSpacePos.xy = clipSpacePos.xy * 0.5f + 0.5f;
    
        float sampleDepth = texture(g_Depth, clipSpacePos.xy).x;
        sampleDepth = ViewPosFromDepth(invProj, clipSpacePos.xy, sampleDepth).z;
    
        float rangeCheck = smoothstep(0.0, 1.0, g_Radius / abs(viewPos.z - sampleDepth));
        occlusion += (sampleDepth >= (samplePos.z + g_Bias) ? 1.0 : 0.0) * rangeCheck;
    }
    
    const float result = 1.f - (occlusion / float(EG_SSAO_SAMPLES));
    imageStore(g_Result, pixelCoords, vec4(result, 0.f, 0.f, 1.f));
}

#include "defines.h"
#include "utils.h"

layout(binding = 0) uniform sampler2D g_Depth;
layout(binding = 1) uniform sampler2D g_Normal;
layout(binding = 2, r8) uniform writeonly image2D g_Result;

layout(push_constant) uniform PushConstants
{
    mat4 g_ProjInv;
    vec3 g_ViewRow1;
    int g_SizeX;
    vec3 g_ViewRow2;
    int g_SizeY;
    vec3 g_ViewRow3;
    float g_Radius;
    float g_RadRotationTemporal;
};

float GTAOFastSqrt(float x)
{
    // [Drobot2014a] Low Level Optimizations for GCN
    return intBitsToFloat(0x1FBD1DF5 + (floatBitsToInt(x) >> 1));
}

float GTAOFastAcos(float x)
{
    // [Eberly2014] GPGPU Programming for Games and Science
    float res = -0.156583 * abs(x) + EG_HALF_PI;
    res *= GTAOFastSqrt(1.f - abs(x));
    return x >= 0.f ? res : EG_PI - res;
}

vec3 GTAO_ViewPosFromDepth(sampler2D depthTexture, mat4 projInv, vec2 uv)
{
    float depth = 0.f;
    if (true)
    {
        // reduces occlusion on thin objects without affecting others
        const vec4 depth4 = textureGather(depthTexture, uv);
        depth = min(min(depth4.x, depth4.y), min(depth4.z, depth4.w));
	}
    else
        depth = texture(depthTexture, uv).x;

    return ViewPosFromDepth(projInv, uv, depth);
}

#define GTAO_FALLOFF 1.5
#define GTAO_THICKNESSMIX 0.2

#define GROUP_SIZE 8
layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;

layout(constant_id = 0) const uint s_Samples = 8;

float IntegrateArc(float h1, float h2, float n)
{
    float cosN = cos(n);
    float sinN = sin(n);
    return 0.25 * (-cos(2.0 * h1 - n) + cosN + 2.0 * h1 * sinN - cos(2.0 * h2 - n) + cosN + 2.0 * h2 * sinN);
}

void main()
{
    const ivec2 pixelCoords = ivec2(gl_GlobalInvocationID);
    if (pixelCoords.x >= g_SizeX || pixelCoords.y >= g_SizeY)
        return;

    const vec2 texelSize = 1.f / vec2(g_SizeX, g_SizeY);
    vec2 UV = (pixelCoords + 0.5) * texelSize;

    const float depth = texture(g_Depth, UV).x;
    if (depth == 1.f)
    {
        imageStore(g_Result, pixelCoords, vec4(0.f));
        return;
    }
    const vec3 viewPos = ViewPosFromDepth(g_ProjInv, UV, depth);

    const mat3 viewMat = mat3(g_ViewRow1, g_ViewRow2, g_ViewRow3);
    const vec3 viewNormal = viewMat * DecodeNormal(texture(g_Normal, UV).xy); // xy - is a geometry normal

    const float radAngle = g_RadRotationTemporal +
		(1.f / 16.f) * ((((pixelCoords.x + pixelCoords.y) & 0x3) << 2) + (pixelCoords.x & 0x3)) * EG_PI * 2.f;

    const vec3 direction = vec3(cos(radAngle), sin(radAngle), 0.f);
    const vec3 viewPosDir = normalize(-viewPos);
    const vec3 orthoDirection = direction - dot(direction, viewPosDir) * viewPosDir;
    const vec3 vsAxis = cross(direction, viewPosDir);
    const vec3 vsProjectedNormal = viewNormal - dot(viewNormal, vsAxis) * vsAxis;
    const float projectedNormalLen = length(vsProjectedNormal);

    const float signN = sign(dot(orthoDirection, vsProjectedNormal));
    const float cosN = dot(vsProjectedNormal, viewPosDir) / projectedNormalLen;
    const float n = GTAOFastAcos(cosN);

    const float radius = min(g_Radius / abs(viewPos.z), g_Radius);
    const uint samples = s_Samples / 2;
    const float ssStep = radius / float(samples);
    
    const float gtaoLimit = 100.f;
    const float gtaoMaxStride = 32.f;
    float stride = min((1.0 / length(viewPos)) * gtaoLimit, gtaoMaxStride);
    vec2 dirMult = vec2(1.f / g_SizeX, 1.f / g_SizeY) * stride;
    vec2 aoDir = dirMult * vec2(sin(radAngle), cos(radAngle));

    UV += aoDir * (0.25 * ((int(pixelCoords.y) - int(pixelCoords.x)) & 3));
    vec2 h = vec2(-1.f);
    for (int side = 0; side <= 1; side++)
    {
        const float sideSign = side == 0 ? -1.f : 1.f;
        const vec2 offset = sideSign * aoDir;
        vec2 uv = UV;

        for (uint i = 0; i < samples; i++)
        {
            uv += offset;

            const vec3 samplePos = GTAO_ViewPosFromDepth(g_Depth, g_ProjInv, uv);
            const vec3 horizon = samplePos - viewPos;
            const float horizonLen = length(horizon);
            float falloff = clamp((g_Radius - horizonLen) / GTAO_FALLOFF, 0.0, 1.0);
            const float cosHorizonCurrent = dot(horizon, viewPosDir) / horizonLen;
            if (cosHorizonCurrent > h[side])
            {
                // Linear falloff for samples that are too far away from current pixel
                h[side] = mix(h[side], cosHorizonCurrent, falloff);
            }
            // Helps avoid overdarkening from thin objects
            h[side] = mix(h[side], cosHorizonCurrent, GTAO_THICKNESSMIX * falloff);
        }
        h[side] = GTAOFastAcos(h[side]);
    }
    h[0] = n + max(-h[0] - n, -EG_HALF_PI);
    h[1] = n + min(h[1] - n, EG_HALF_PI);

    float ao = mix(1.f, IntegrateArc(h[0], h[1], n), projectedNormalLen);
    imageStore(g_Result, pixelCoords, vec4(ao, 0.f, 0.f, 1.f));
}

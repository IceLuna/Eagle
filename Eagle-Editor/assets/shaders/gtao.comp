#include "defines.h"
#include "utils.h"

layout(binding = 0) uniform sampler2D g_Depth;
layout(binding = 1) uniform sampler2D g_Normal;
layout(binding = 2, r8) uniform writeonly image2D g_Result;

layout(push_constant) uniform PushConstants
{
    mat4 g_ProjInv;
    vec3 g_ViewRow1;
    int g_SizeX;
    vec3 g_ViewRow2;
    int g_SizeY;
    vec3 g_ViewRow3;
    float g_Radius;
    float g_RadRotationTemporal;
};

float GTAOFastSqrt(float x)
{
    // [Drobot2014a] Low Level Optimizations for GCN
    return intBitsToFloat(0x1FBD1DF5 + (floatBitsToInt(x) >> 1));
}

float GTAOFastAcos(float x)
{
    // [Eberly2014] GPGPU Programming for Games and Science
    float res = -0.156583 * abs(x) + EG_HALF_PI;
    res *= GTAOFastSqrt(1.f - abs(x));
    return x >= 0.f ? res : EG_PI - res;
}

vec3 GTAO_ViewPosFromDepth(sampler2D depthTexture, mat4 projInv, vec2 uv)
{
    float depth = 0.f;
	if (true)
    {
        // reduces occlusion on thin objects without affecting others
		const vec4 depth4 = textureGather(depthTexture, uv);
		depth = min(min(depth4.x, depth4.y), min(depth4.z, depth4.w));
	}
    else
		depth = texture(depthTexture, uv).x;

    return ViewPosFromDepth(projInv, uv, depth);
}

#define GTAO_FALLOFF 1.5
#define GTAO_THICKNESSMIX 0.2

#define GROUP_SIZE 8
layout(local_size_x = GROUP_SIZE, local_size_y = GROUP_SIZE) in;

void main()
{
    const ivec2 pixelCoords = ivec2(gl_GlobalInvocationID);
    if (pixelCoords.x >= g_SizeX || pixelCoords.y >= g_SizeY)
        return;

    const vec2 texelSize = 1.f / vec2(g_SizeX, g_SizeY);
    const vec2 UV = (pixelCoords + 0.5) * texelSize;

    const float depth = texture(g_Depth, UV).x;
    if (depth == 1.f)
    {
        imageStore(g_Result, pixelCoords, vec4(0.f));
        return;
    }
    const vec3 viewPos = ViewPosFromDepth(g_ProjInv, UV, depth);

    const mat3 viewMat = mat3(g_ViewRow1, g_ViewRow2, g_ViewRow3);
    const vec3 viewNormal = viewMat * DecodeNormal(texture(g_Normal, UV).zw); // zw - is a shading normal

    const float radAngle = g_RadRotationTemporal +
		(1.f / 16.f) * ((((pixelCoords.x + pixelCoords.y) & 0x3) << 2) + (pixelCoords.x & 0x3)) * EG_PI * 2.f;

    const vec3 direction = vec3(cos(radAngle), sin(radAngle), 0.f);
    const vec3 viewPosDir = normalize(-viewPos);
    const vec3 orthoDirection = direction - dot(direction, viewPosDir) * viewPosDir;
    const vec3 vsAxis = cross(direction, viewPosDir);
    const vec3 vsProjectedNormal = viewNormal - dot(viewNormal, vsAxis) * vsAxis;
    const float projectedNormalLen = length(vsProjectedNormal);

    const float signN = sign(dot(orthoDirection, vsProjectedNormal));
    const float cosN = clamp(dot(vsProjectedNormal, viewPosDir) / projectedNormalLen, 0.f, 1.f);
    const float n = signN * GTAOFastAcos(cosN);

	const float radius = min(g_Radius / abs(viewPos.z), g_Radius);
    const float ssStep = radius / float(EG_GTAO_SAMPLES);

    const float sinN = sin(n);
    float ao = 0.f;

    for (int side = 0; side <= 1; side++)
    {
        const float sideSign = side == 0 ? -1.f : 1.f;
        vec2 uv = UV;
        uv += sideSign * direction.xy *
            0.25f * ((pixelCoords.y - pixelCoords.x) & 0x3) * texelSize;

        const vec2 offset = sideSign * direction.xy * ssStep;

        float h = -1.f;
        for (uint i = 0; i < EG_GTAO_SAMPLES; i++)
        {
            uv += offset;

            const vec3 samplePos = GTAO_ViewPosFromDepth(g_Depth, g_ProjInv, uv);
            const vec3 horizon = samplePos - viewPos;
            const float horizonLen = length(horizon);
            float falloff = clamp((g_Radius - horizonLen) / GTAO_FALLOFF, 0.0, 1.0);
            const float cosHorizonCurrent = dot(horizon, viewPosDir) / horizonLen;
            if (cosHorizonCurrent > h)
            {
                // Linear falloff for samples that are too far away from current pixel
                h = mix(h, cosHorizonCurrent, falloff);
            }
            // Helps avoid overdarkening from thin objects
            h = mix(h, cosHorizonCurrent, GTAO_THICKNESSMIX * falloff);
        }
        h = sideSign * GTAOFastAcos(h);
        h = n + max(h - n, -EG_HALF_PI);

        ao += (projectedNormalLen * 0.25f * (cosN + 2.f * h * sinN - cos(2.f * h - n)));
    }

    ao = mix(1.f, ao, projectedNormalLen);
    imageStore(g_Result, pixelCoords, vec4(ao, 0.f, 0.f, 1.f));
}
